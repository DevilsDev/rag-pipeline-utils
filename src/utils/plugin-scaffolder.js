/**
 * Version: 1.0.0
 * Path: /src/utils/plugin-scaffolder.js
 * Description: Plugin scaffolding utility for creating new plugins with best practices
 * Author: Ali Kahwaji
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { pluginContracts } from '../core/plugin-contracts.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export class PluginScaffolder {
  constructor(options = {}) {
    this.outputDir = options.outputDir || process.cwd();
    this.author = options.author || 'Your Name';
    this.namespace = options.namespace || 'your-namespace';
  }

  /**
   * Scaffold a new plugin with all necessary files
   * @param {string} pluginType - Type of plugin (loader, embedder, retriever, llm, reranker)
   * @param {string} pluginName - Name of the plugin
   * @param {object} options - Additional options
   */
  async scaffoldPlugin(pluginType, pluginName, options = {}) {
    if (!pluginContracts[pluginType]) {
      throw new Error(`Unknown plugin type: ${pluginType}. Available types: ${Object.keys(pluginContracts).join(', ')}`);
    }

    const pluginDir = path.join(this.outputDir, `${pluginName}-${pluginType}`);
    
    // Create plugin directory
    if (!fs.existsSync(pluginDir)) {
      fs.mkdirSync(pluginDir, { recursive: true });
    }

    // Generate all plugin files
    await this.generatePluginFile(pluginDir, pluginType, pluginName, options);
    await this.generateTestFile(pluginDir, pluginType, pluginName);
    await this.generateMockFile(pluginDir, pluginType, pluginName);
    await this.generateConfigExample(pluginDir, pluginType, pluginName);
    await this.generateReadme(pluginDir, pluginType, pluginName, options);
    await this.generatePackageJson(pluginDir, pluginType, pluginName, options);

    console.log(`âœ… Plugin scaffolded successfully at: ${pluginDir}`);
    console.log('ðŸ“ Generated files:');
    console.log(`   - src/${pluginName}-${pluginType}.js (main plugin)`);
    console.log(`   - __tests__/${pluginName}-${pluginType}.test.js (tests)`);
    console.log(`   - mocks/${pluginName}-${pluginType}-mock.js (mock implementation)`);
    console.log('   - .ragrc.example.json (configuration example)');
    console.log('   - README.md (documentation)');
    console.log('   - package.json (npm package)');
  }

  /**
   * Generate the main plugin implementation file
   */
  async generatePluginFile(pluginDir, pluginType, pluginName, options) {
    const contract = pluginContracts[pluginType];
    const className = this.toPascalCase(`${pluginName}_${pluginType}`);
    const srcDir = path.join(pluginDir, 'src');
    
    if (!fs.existsSync(srcDir)) {
      fs.mkdirSync(srcDir, { recursive: true });
    }

    const methods = contract.requiredMethods.map(methodName => {
      const signature = contract.methodSignatures?.[methodName];
      return this.generateMethodStub(methodName, signature);
    }).join('\n\n');

    const optionalMethods = contract.optionalMethods?.map(methodName => {
      const signature = contract.methodSignatures?.[methodName];
      return this.generateMethodStub(methodName, signature, true);
    }).join('\n\n') || '';

    const content = `/**
 * ${className} - ${pluginType} plugin implementation
 * Generated by RAG Pipeline Utils Plugin Scaffolder
 * Author: ${this.author}
 */

export class ${className} {
  constructor(options = {}) {
    // Initialize your plugin with configuration options
    this.options = options;
    
    // Add your initialization logic here
    // Example: this.apiKey = options.apiKey;
    // Example: this.endpoint = options.endpoint || 'https://api.example.com';
  }

${methods}${optionalMethods ? '\n\n  // Optional methods\n' + optionalMethods : ''}
}

// Export default instance for easy use
export default ${className};
`;

    const filePath = path.join(srcDir, `${pluginName}-${pluginType}.js`);
    fs.writeFileSync(filePath, content);
  }

  /**
   * Generate method stub with proper signature
   */
  generateMethodStub(methodName, signature, isOptional = false) {
    const params = signature?.params || ['input'];
    const paramTypes = signature?.paramTypes || ['any'];
    const returnType = signature?.returnType || 'Promise<any>';
    const description = signature?.description || `${isOptional ? 'Optional: ' : ''}Implement ${methodName} functionality`;

    const paramList = params.map((param, i) => `${param}`).join(', ');
    const paramDocs = params.map((param, i) => `   * @param {${paramTypes[i]}} ${param}`).join('\n');

    return `  /**
   * ${description}
${paramDocs}
   * @returns {${returnType}}
   */
  async ${methodName}(${paramList}) {
    // TODO: Implement ${methodName} logic
    throw new Error('${methodName} not yet implemented');
  }`;
  }

  /**
   * Generate test file
   */
  async generateTestFile(pluginDir, pluginType, pluginName) {
    const className = this.toPascalCase(`${pluginName}_${pluginType}`);
    const testDir = path.join(pluginDir, '__tests__');
    
    if (!fs.existsSync(testDir)) {
      fs.mkdirSync(testDir, { recursive: true });
    }

    const contract = pluginContracts[pluginType];
    const testCases = contract.requiredMethods.map(method => {
      return `  describe('${method}', () => {
    it('should implement ${method} method', () => {
      expect(typeof plugin.${method}).toBe('function');
    });

    it('should handle ${method} functionality', async () => {
      // TODO: Add specific test cases for ${method}
      // Example: const result = await plugin.${method}(testInput);
      // Example: expect(result).toBeDefined();
    });
  });`;
    }).join('\n\n');

    const content = `/**
 * Tests for ${className}
 * Generated by RAG Pipeline Utils Plugin Scaffolder
 */

import { ${className} } from '../src/${pluginName}-${pluginType}.js';

describe('${className}', () => {
  let plugin;

  beforeEach(() => {
    plugin = new ${className}({
      // Add test configuration options here
    });
  });

  describe('constructor', () => {
    it('should create instance with default options', () => {
      const instance = new ${className}();
      expect(instance).toBeInstanceOf(${className});
    });

    it('should accept configuration options', () => {
      const options = { testOption: 'value' };
      const instance = new ${className}(options);
      expect(instance.options).toEqual(options);
    });
  });

${testCases}

  describe('error handling', () => {
    it('should handle invalid inputs gracefully', async () => {
      // TODO: Add error handling tests
      // Example: await expect(plugin.someMethod(null)).rejects.toThrow();
    });
  });
});
`;

    const filePath = path.join(testDir, `${pluginName}-${pluginType}.test.js`);
    fs.writeFileSync(filePath, content);
  }

  /**
   * Generate mock implementation file
   */
  async generateMockFile(pluginDir, pluginType, pluginName) {
    const className = this.toPascalCase(`${pluginName}_${pluginType}`);
    const mockDir = path.join(pluginDir, 'mocks');
    
    if (!fs.existsSync(mockDir)) {
      fs.mkdirSync(mockDir, { recursive: true });
    }

    const contract = pluginContracts[pluginType];
    const mockMethods = contract.requiredMethods.map(methodName => {
      return `  async ${methodName}(...args) {
    // Mock implementation for ${methodName}
    console.log(\`Mock ${className}.${methodName} called with:\`, args);
    return \`Mock result from ${methodName}\`;
  }`;
    }).join('\n\n');

    const content = `/**
 * Mock implementation of ${className}
 * Generated by RAG Pipeline Utils Plugin Scaffolder
 * Use this for testing and development
 */

export class Mock${className} {
  constructor(options = {}) {
    this.options = options;
    this.mockMode = true;
  }

${mockMethods}
}

// Export default instance for easy use
export default new Mock${className}();
`;

    const filePath = path.join(mockDir, `${pluginName}-${pluginType}-mock.js`);
    fs.writeFileSync(filePath, content);
  }

  /**
   * Generate configuration example
   */
  async generateConfigExample(pluginDir, pluginType, pluginName) {
    const config = {
      [pluginType]: {
        [pluginName]: `./src/${pluginName}-${pluginType}.js`
      },
      namespace: `${pluginName}-namespace`,
      pipeline: ['loader', 'embedder', 'retriever']
    };

    const content = JSON.stringify(config, null, 2);
    const filePath = path.join(pluginDir, '.ragrc.example.json');
    fs.writeFileSync(filePath, content);
  }

  /**
   * Generate README documentation
   */
  async generateReadme(pluginDir, pluginType, pluginName, options) {
    const className = this.toPascalCase(`${pluginName}_${pluginType}`);
    const contract = pluginContracts[pluginType];

    const methodDocs = contract.requiredMethods.map(method => {
      const signature = contract.methodSignatures?.[method];
      return `### \`${method}(${signature?.params?.join(', ') || '...args'})\`

${signature?.description || `Implements ${method} functionality`}

**Parameters:**
${signature?.params?.map((param, i) => `- \`${param}\` (${signature.paramTypes?.[i] || 'any'})`).join('\n') || '- TBD'}

**Returns:** \`${signature?.returnType || 'Promise<any>'}\``;
    }).join('\n\n');

    const content = `# ${className}

A ${pluginType} plugin for RAG Pipeline Utils.

## Description

${options.description || `This plugin provides ${pluginType} functionality for RAG (Retrieval-Augmented Generation) pipelines.`}

## Installation

\`\`\`bash
npm install ${this.namespace}/${pluginName}-${pluginType}
\`\`\`

## Usage

### Basic Usage

\`\`\`javascript
import { ${className} } from '${this.namespace}/${pluginName}-${pluginType}';

const plugin = new ${className}({
  // Configuration options
});

// Use the plugin methods
// const result = await plugin.someMethod(input);
\`\`\`

### With RAG Pipeline Utils

\`\`\`json
{
  "${pluginType}": {
    "${pluginName}": "./src/${pluginName}-${pluginType}.js"
  }
}
\`\`\`

## API Reference

${methodDocs}

## Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| \`option1\` | \`string\` | \`"default"\` | Description of option1 |
| \`option2\` | \`number\` | \`100\` | Description of option2 |

## Testing

\`\`\`bash
npm test
\`\`\`

## Development

1. Clone the repository
2. Install dependencies: \`npm install\`
3. Run tests: \`npm test\`
4. Build: \`npm run build\`

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests
5. Submit a pull request

## License

MIT

## Author

${this.author}
`;

    const filePath = path.join(pluginDir, 'README.md');
    fs.writeFileSync(filePath, content);
  }

  /**
   * Generate package.json
   */
  async generatePackageJson(pluginDir, pluginType, pluginName, options) {
    const packageName = `${this.namespace}/${pluginName}-${pluginType}`;
    
    const packageJson = {
      name: packageName,
      version: '1.0.0',
      description: options.description || `A ${pluginType} plugin for RAG Pipeline Utils`,
      main: `src/${pluginName}-${pluginType}.js`,
      type: 'module',
      scripts: {
        test: 'jest',
        'test:watch': 'jest --watch',
        lint: 'eslint src/ __tests__/',
        'lint:fix': 'eslint src/ __tests__/ --fix'
      },
      keywords: [
        'rag',
        'pipeline',
        'plugin',
        pluginType,
        'ai',
        'ml'
      ],
      author: this.author,
      license: 'MIT',
      peerDependencies: {
        '@devilsdev/rag-pipeline-utils': '^2.0.0'
      },
      devDependencies: {
        'jest': '^29.7.0',
        'eslint': '^8.57.1'
      },
      files: [
        'src/',
        'mocks/',
        'README.md',
        '.ragrc.example.json'
      ]
    };

    const content = JSON.stringify(packageJson, null, 2);
    const filePath = path.join(pluginDir, 'package.json');
    fs.writeFileSync(filePath, content);
  }

  /**
   * Convert string to PascalCase
   */
  toPascalCase(str) {
    return str
      .split(/[-_\s]/)
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('');
  }
}

export default PluginScaffolder;
